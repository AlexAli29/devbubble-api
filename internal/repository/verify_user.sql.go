// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: verify_user.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const verifyUser = `-- name: VerifyUser :one
WITH matched_user AS (
  SELECT 
    "u"."id",
    "ac"."id" as "authCodeId" -- Получаем ID кода аутентификации для последующего обновления
  FROM 
    "users" "u"
    INNER JOIN "auth_codes" "ac" ON "u"."id" = "ac"."userId"
  WHERE 
    "u"."email" = $1 -- Плейсхолдер для параметра email
    AND "ac"."code" = $2 -- Плейсхолдер для параметра кода аутентификации
    AND "ac"."updatedAt" >= NOW() - INTERVAL '10 minutes'
),
updated_users AS (
  UPDATE "users"
  SET "isVerified" = TRUE
  FROM matched_user
  WHERE "users"."id" = matched_user.id
  RETURNING "users"."id"
),
updated_auth_code AS (
  UPDATE "auth_codes"
  SET 
    "code" = floor(random() * 900000 + 100000), -- Генерируем новый код
    "updatedAt" = NOW() -- Обновляем время
  FROM matched_user
  WHERE "auth_codes"."id" = matched_user."authCodeId" -- Обновляем существующий код аутентификации
  RETURNING "auth_codes"."userId"
)
SELECT "id" FROM updated_users
`

type VerifyUserParams struct {
	Email string `json:"email"`
	Code  int32  `json:"code"`
}

func (q *Queries) VerifyUser(ctx context.Context, arg VerifyUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, verifyUser, arg.Email, arg.Code)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
